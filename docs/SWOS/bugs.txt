- InputText() doesn't limit text input correctly if buffer is initialized with string longer than limit
- when goalkeeper is kicking the ball and scores own goal, he won't be set as a goal scorer, instead the player who
  last played will be assigned as own-goal scorer
- ClearBackground() - only sets lower part of edx but uses full 32-bit register, only works if upper 16 bits of the
  register are zero by accident
- this could also be called an internal bug, in ReadGamePort() cx is loaded with number of loop iterations, but it's
  first decremented and then tested, so if it's a zero we get (almost) infinite loop: complete 2^32 loop with
  interrupts turned off
- not all variables are completely initialized before the game, but that didn't manifest before multiplayer games
  (for example fractional part of the ball coordinate remains intact from the previous game, so in time it
  accumulates over 1)
- SaveRandState() overwrites first byte of big_S_Sprite. That byte is part of first word - team number which is not
  used anyway. But still it remains unknown whether this is intentional or not.
- DoUnchainSpriteInMenus() starts with mov cx, word [D1] but uses full ecx later
- game lengths are too short... only took 20 years to notice :D
- when the bench is called while the goalkeeper holds the ball GoalkeeperClaimedTheBall() is called without setting
  A2 to ball sprite (it was randomly set to currentPlayerNameSprite when I checked), then the speed of "ball" sprite
  is set to 0
- in UpdateBookedPlayerNumberSprite() three tables are used, they should all be 30 bytes long but the third one only
  has 27 bytes; on top of it, all three are identical (bar last 3 bytes in 3rd)
- also in UpdateBookedPlayerNumberSprite(): it calls SendPlayerAway() which expects team pointer in A6, but it's
  never set! seems the team remains in A6 from one of many previous function calls in main loop, and happens to be
  the one sent away player belongs to (however it's only used to check if the player is marked and to clear that
  mark, so it could even be wrong)
- sound issue when game ends in a draw (to be checked)
- IsThisPlayerOkToSelect() has a broken logic in case when player substituted field is false and position is -1 (-1
  means the player was already substituted). In this case D0 register that is used as return value isn't initialized
  properly and contains player offset (which is positive), thus forcing return value "OK", which is wrong. Also, the
  condition might have superfluous parts (this combination might never happen).
- AI_SetControlsDirection() + 0x687: accessing A5 team pointer that's null
