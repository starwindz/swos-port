Highlights are recorded by storing the camera coordinates, result, animated patterns state and every visible
sprite coordinate in the frame. One highlight scene is comprised of many frames. Buffer for each scene is
19,000 bytes long. It is in fact a circular buffer, and as data keeps pouring in, it overwrites the oldest
entries. End is detected by -1 marker.

Bookkeeping is maintained via three pointers:
goalBasePtr     - points to the start of the current scene buffer
nextGoalPtr     - points to the next scene (end of the current)
currentHilPtr   - pointer in the current scene, how much was filled

Current pointer keeps increasing, and when it reaches the end of the buffer it is reset to the beginning. This
way the oldest entries are overwritten with the newest. After each write a special marker -1 is written and
the pointer isn't bumped so any new data overwrites it. This marker allows the game to find the start of the
scene later on.

Maximum storage is 10 scenes. If there are more, only 10 latest are kept, by shifting all the highlights down.
After eventual shifting, scene data is copied from current buffer to a more permanent area (which will go to
file eventually). Done by SaveHighlightScene().

When copying to a permanent area, the scene is copied starting from the oldest data. It is located right after
the current pointer, but since the frame might contain arbitrary number of sprites, we have to find the start
of it (which will be marked by the dword with the highest bit set). It's crucial to start from the dword with
the high bit set since the buffer pointer might wrap in the middle of the frame, so we can not rely on simply
reading the range [base ptr - current ptr].

Contents of the scene buffer can be viewed by pressing 'R' during the game. The game will fade-out and replay
short segment that's currently in the highlights working buffer. To find the start of the scene, buffer is
searched for the first value with the high bit set (start of frame marker), taking care of wrapping the
pointer. Pressing 'R' during the playback toggles slow motion mode.

Highlight file data area contains a header, variables global for the current highlight, and extends into scene
buffer area. It starts with hilFileBuffer -- a header for the highlight file. Each scene can be maximum 19,000
bytes long, and there is room for 10 scenes. Anything beyond that will start overwriting older scenes.


offset:  size:  desc.
-------  -----  -----
   0       4    8 - might be the offset to the first team?
   4       4    193626 - this happens to be the maximum size of the file:
                    = 10 x 19000 + 8 + 2 x 1704 + 210
                these two dwords are written as constants (never change), so they could be used as a way of
                detecting hil files
   8     1704   first (top) team, in-game structure
1712     1704   second (bottom) team
3416      100   name of the game, league, contest... (e.g. "FRIENDLY", "RUSSIAN PREMIER DIVISION", ...)
                only first 40 bytes are used; haven't seen it get read-in and used in the game, might contain
                remains of previous write (buffer is never cleared)
3516      100   round, if the game is a cup (e.g. "FIRST ROUND"); same applies as the above
3616        2   number of scenes in the file
3618        2   number of goals for first team
3620        2   number of goals for second team
3622        2   lower byte - number of pitch file, higher byte - pitch type
3624        2   number of maximum substitutes
3626   19000    buffer...
         x      it contains info about the scene
       number   each scene takes up to 19,000 bytes
      of goals  (exact end is determined by dword -1 marker)

                Scene starts with the first negative 32-bit int (highest bit set). A search is conducted.

                This dword first contains x and y camera coordinates (respectively, without the highest bit),
                and next:
                word: team 1 number of goals
                word: team 2 number of goals (as it was at the beginning of the scene)
                2x same word: animated patterns state [0..7] (how much to jump)

                followed by a dword array:

                if the highest bit isn't set, it's a sprite of the following format:

                 31            20 19        10 9           0
                +-+--------------+------------+-------------+
                |0|              |            |             |
                +-+--------------+------------+-------------+
                 sprite index          x             y
                   11 bits          10 bits       10 bits

                x and y coordinates are signed, bits 9 and 19 are the sign bits. A single frame ends with the
                first dword having highest bit set, and a single scene by running into dword -1 or iterating
                over 19,000 bytes.


Notes on expanding the file format
----------------------------------
Extra data could go to the end of the file, but it's crucial the they don't have the highest bit set. In this
case, the data could be injected right before the beginning of each scene, if that wouldn't cause "shortening"
of the scene. What's required might be a function that could map an arbitrary array of bytes into a new array
of bytes such that each fourth byte (dword) does not have the highest bit set. If input is broken into bits
we'd get a simple encryption for free.
